{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/Presale.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title BackroomPresale\n * @dev Presale contract for Backroom token with ETH contributions\n * Features:\n * - 24-hour contribution window\n * - One contribution per address\n * - Soft cap / Hard cap mechanics\n * - Min/Max contribution limits\n * - Refund mechanism for failed sales\n */\ncontract BackroomPresale is Ownable, ReentrancyGuard {\n    // Sale Parameters\n    uint256 public softCap; // Minimum ETH to raise for success\n    uint256 public hardCap; // Maximum ETH before early close\n    uint256 public minContribution; // Minimum ETH per address\n    uint256 public maxContribution; // Maximum ETH per address\n\n    // Sale State\n    uint256 public saleStartTime; // When sale begins\n    uint256 public saleEndTime; // When sale ends (24h after start)\n    uint256 public totalRaised; // Total ETH raised\n    bool public saleFinalized; // Has sale been finalized\n    bool public saleSuccessful; // Did sale meet soft cap\n\n    // Constants\n    uint256 public constant SALE_DURATION = 24 hours;\n\n    // Participant tracking\n    mapping(address => uint256) public contributions; // ETH contributed per address\n    mapping(address => bool) public hasContributed; // Track if address contributed\n    mapping(address => bool) public hasRefunded; // Track refund claims\n\n    address[] public contributors; // Array of all contributors\n\n    event SaleStarted(uint256 startTime, uint256 endTime);\n    event ContributionMade(address indexed contributor, uint256 amount);\n    event SaleFinalized(bool successful, uint256 totalRaised);\n    event RefundClaimed(address indexed contributor, uint256 amount);\n    event FundsWithdrawn(uint256 amount);\n\n    modifier onlyDuringSale() {\n        require(saleStartTime > 0, \"Sale not started\");\n        require(block.timestamp >= saleStartTime, \"Sale not started\");\n        require(block.timestamp <= saleEndTime, \"Sale ended\");\n        require(totalRaised < hardCap, \"Hard cap reached\");\n        _;\n    }\n\n    modifier onlyAfterSale() {\n        require(saleFinalized, \"Sale not finalized\");\n        _;\n    }\n\n    constructor(\n        uint256 _softCap,\n        uint256 _hardCap,\n        uint256 _minContribution,\n        uint256 _maxContribution\n    ) Ownable(msg.sender) {\n        require(_softCap > 0, \"Soft cap must be > 0\");\n        require(_hardCap > _softCap, \"Hard cap must be > soft cap\");\n        require(_minContribution > 0, \"Min contribution must be > 0\");\n        require(\n            _maxContribution >= _minContribution,\n            \"Max must be >= min contribution\"\n        );\n        require(\n            _maxContribution <= _hardCap,\n            \"Max contribution cannot exceed hard cap\"\n        );\n\n        softCap = _softCap;\n        hardCap = _hardCap;\n        minContribution = _minContribution;\n        maxContribution = _maxContribution;\n    }\n\n    /**\n     * @dev Start the presale (admin only)\n     */\n    function startSale() external onlyOwner {\n        require(\n            block.timestamp > saleEndTime || saleStartTime == 0,\n            \"Sale already active or finalized\"\n        );\n        require(!saleFinalized, \"Sale already finalized\");\n\n        saleStartTime = block.timestamp;\n        saleEndTime = block.timestamp + SALE_DURATION;\n\n        emit SaleStarted(saleStartTime, saleEndTime);\n    }\n\n    /**\n     * @dev Contribute ETH to the presale\n     */\n    function deposit() external payable onlyDuringSale nonReentrant {\n        require(msg.value >= minContribution, \"Below minimum contribution\");\n        require(!hasContributed[msg.sender], \"Already contributed\");\n        require(msg.value <= maxContribution, \"Exceeds maximum contribution\");\n        require(totalRaised + msg.value <= hardCap, \"Would exceed hard cap\");\n\n        // Record contribution\n        contributions[msg.sender] = msg.value;\n        hasContributed[msg.sender] = true;\n        contributors.push(msg.sender);\n        totalRaised += msg.value;\n\n        emit ContributionMade(msg.sender, msg.value);\n\n        // Auto-finalize if hard cap reached\n        if (totalRaised >= hardCap) {\n            _finalizeSale();\n        }\n    }\n\n    /**\n     * @dev Finalize the sale after 24 hours or when hard cap is reached\n     */\n    function finalizeSale() external {\n        require(!saleFinalized, \"Sale already finalized\");\n        require(\n            block.timestamp > saleEndTime || totalRaised >= hardCap,\n            \"Sale period not ended and hard cap not reached\"\n        );\n\n        _finalizeSale();\n    }\n\n    /**\n     * @dev Internal function to finalize sale\n     */\n    function _finalizeSale() internal {\n        saleFinalized = true;\n        saleSuccessful = totalRaised >= softCap;\n\n        emit SaleFinalized(saleSuccessful, totalRaised);\n    }\n\n    /**\n     * @dev Claim refund if sale failed (contributors only)\n     */\n    function claimRefund() external onlyAfterSale nonReentrant {\n        require(!saleSuccessful, \"Sale was successful, no refunds\");\n        require(hasContributed[msg.sender], \"No contribution found\");\n        require(!hasRefunded[msg.sender], \"Already refunded\");\n\n        uint256 refundAmount = contributions[msg.sender];\n        require(refundAmount > 0, \"No refund available\");\n\n        hasRefunded[msg.sender] = true;\n\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n\n        emit RefundClaimed(msg.sender, refundAmount);\n    }\n\n    /**\n     * @dev Withdraw raised funds if sale was successful (admin only)\n     */\n    function withdrawFunds() external onlyOwner onlyAfterSale {\n        require(saleSuccessful, \"Sale was not successful\");\n\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No funds to withdraw\");\n\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        emit FundsWithdrawn(amount);\n    }\n\n    // ************************************\n    // ********** View Functions **********\n    // ************************************\n\n    /**\n     * @dev Get sale status information\n     */\n    function getSaleInfo()\n        external\n        view\n        returns (\n            bool _saleFinalized,\n            bool _saleSuccessful,\n            uint256 _totalRaised,\n            uint256 _startTime,\n            uint256 _endTime,\n            uint256 _contributors\n        )\n    {\n        return (\n            saleFinalized,\n            saleSuccessful,\n            totalRaised,\n            saleStartTime,\n            saleEndTime,\n            contributors.length\n        );\n    }\n\n    /**\n     * @dev Get contribution info for an address\n     */\n    function getContributionInfo(\n        address _contributor\n    )\n        external\n        view\n        returns (uint256 _contribution, bool _hasContributed, bool _hasRefunded)\n    {\n        return (\n            contributions[_contributor],\n            hasContributed[_contributor],\n            hasRefunded[_contributor]\n        );\n    }\n\n    /**\n     * @dev Get all contributors (for off-chain token allocation calculation)\n     */\n    function getContributors() external view returns (address[] memory) {\n        return contributors;\n    }\n\n    /**\n     * @dev Get time remaining in sale\n     */\n    function getTimeRemaining() external view returns (uint256) {\n        if (saleStartTime == 0 || block.timestamp >= saleEndTime) {\n            return 0;\n        }\n        return saleEndTime - block.timestamp;\n    }\n\n    /**\n     * @dev Calculate token allocation for a contributor (view only, for off-chain reference)\n     * @param _contributor Address to calculate for\n     * @param _totalTokensAllocated Total tokens allocated to presale (e.g., 5% of supply)\n     */\n    function calculateTokenAllocation(\n        address _contributor,\n        uint256 _totalTokensAllocated\n    ) external view returns (uint256) {\n        require(\n            saleFinalized && saleSuccessful,\n            \"Sale not successfully finalized\"\n        );\n        require(totalRaised > 0, \"No contributions\");\n\n        uint256 contributorETH = contributions[_contributor];\n        if (contributorETH == 0) return 0;\n\n        // UserTokens = (User ETH / Total ETH Raised) Ã— Total Allocated Tokens\n        return (contributorETH * _totalTokensAllocated) / totalRaised;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}